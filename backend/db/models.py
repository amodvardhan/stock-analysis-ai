"""
=============================================================================
AI Hub - Database Models (Tables)
=============================================================================
Defines all database tables using SQLAlchemy ORM.

Tables:
1. User - User accounts and authentication
2. Stock - Stock information and cached data
3. Portfolio - User's portfolio container
4. PortfolioHolding - Individual stock holdings in portfolio
5. PortfolioTransaction - Transaction history (buy/sell)
6. Watchlist - Stocks user wants to monitor
7. StockAnalysis - AI-generated analysis results
8. TradingSignal - Buy/sell signals generated by AI
9. Notification - Notification history
=============================================================================
"""

from datetime import datetime
from typing import List, Optional
from sqlalchemy import (
    Boolean,
    Column,
    DateTime,
    Float,
    ForeignKey,
    Integer,
    String,
    Text,
    UniqueConstraint,
    Index,
    Enum as SQLEnum,
    DECIMAL,
)
from sqlalchemy.orm import Mapped, mapped_column, relationship
from sqlalchemy.dialects.postgresql import JSONB, UUID
from pgvector.sqlalchemy import Vector
import enum
import uuid

from core.database import Base


# -------------------------
# Enumerations
# -------------------------
class MarketType(str, enum.Enum):
    """Stock market types"""
    INDIA_NSE = "india_nse"
    INDIA_BSE = "india_bse"
    US_NYSE = "us_nyse"
    US_NASDAQ = "us_nasdaq"


class SignalType(str, enum.Enum):
    """Trading signal types"""
    BUY = "buy"
    SELL = "sell"
    HOLD = "hold"


class NotificationType(str, enum.Enum):
    """Notification delivery methods"""
    EMAIL = "email"
    SMS = "sms"
    IN_APP = "in_app"


class NotificationStatus(str, enum.Enum):
    """Notification delivery status"""
    PENDING = "pending"
    SENT = "sent"
    FAILED = "failed"


class TransactionType(str, enum.Enum):
    """Portfolio transaction types"""
    BUY = "BUY"
    SELL = "SELL"


# -------------------------
# User Model
# -------------------------
class User(Base):
    """
    User account table.
    Stores user credentials, preferences, and notification settings.
    """
    __tablename__ = "users"

    # Primary key
    id: Mapped[uuid.UUID] = mapped_column(
        UUID(as_uuid=True),
        primary_key=True,
        default=uuid.uuid4,
        comment="Unique user identifier"
    )

    # Authentication fields
    email: Mapped[str] = mapped_column(
        String(255),
        unique=True,
        nullable=False,
        index=True,
        comment="User email (used for login)"
    )
    hashed_password: Mapped[str] = mapped_column(
        String(255),
        nullable=False,
        comment="Bcrypt hashed password"
    )

    # Profile information
    full_name: Mapped[str] = mapped_column(
        String(255),
        nullable=False,
        comment="User's full name"
    )
    phone_number: Mapped[Optional[str]] = mapped_column(
        String(20),
        nullable=True,
        comment="Phone number for SMS notifications"
    )

    # User preferences
    risk_tolerance: Mapped[Optional[str]] = mapped_column(
        String(20),
        default="moderate",
        comment="Risk tolerance: conservative, moderate, aggressive"
    )
    preferred_markets: Mapped[Optional[dict]] = mapped_column(
        JSONB,
        default=list,
        comment="List of preferred markets"
    )

    # Notification preferences
    email_notifications: Mapped[bool] = mapped_column(
        Boolean,
        default=True,
        comment="Enable email notifications"
    )
    sms_notifications: Mapped[bool] = mapped_column(
        Boolean,
        default=False,
        comment="Enable SMS notifications"
    )

    # Account status
    is_active: Mapped[bool] = mapped_column(
        Boolean,
        default=True,
        comment="Account active status"
    )
    is_verified: Mapped[bool] = mapped_column(
        Boolean,
        default=False,
        comment="Email verification status"
    )

    # Timestamps
    created_at: Mapped[datetime] = mapped_column(
        DateTime,
        default=datetime.utcnow
    )
    updated_at: Mapped[datetime] = mapped_column(
        DateTime,
        default=datetime.utcnow,
        onupdate=datetime.utcnow
    )
    last_login: Mapped[Optional[datetime]] = mapped_column(
        DateTime,
        nullable=True
    )

    # Relationships
    portfolios: Mapped[List["Portfolio"]] = relationship(
        "Portfolio",
        back_populates="user",
        cascade="all, delete-orphan"
    )
    watchlists: Mapped[List["Watchlist"]] = relationship(
        "Watchlist",
        back_populates="user",
        cascade="all, delete-orphan"
    )
    notifications: Mapped[List["Notification"]] = relationship(
        "Notification",
        back_populates="user",
        cascade="all, delete-orphan"
    )

    def __repr__(self) -> str:
        return f"<User {self.email}>"


# -------------------------
# Stock Model
# -------------------------
class Stock(Base):
    """Stock information table with cached market data."""
    __tablename__ = "stocks"

    id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True)

    # Stock identifiers
    symbol: Mapped[str] = mapped_column(
        String(20),
        nullable=False,
        index=True,
        comment="Stock ticker symbol"
    )
    market: Mapped[MarketType] = mapped_column(
        SQLEnum(MarketType),
        nullable=False,
        comment="Stock market"
    )

    # Stock information
    company_name: Mapped[str] = mapped_column(String(255), nullable=False)
    sector: Mapped[Optional[str]] = mapped_column(String(100), nullable=True)
    industry: Mapped[Optional[str]] = mapped_column(String(100), nullable=True)

    # Cached market data
    current_price: Mapped[Optional[float]] = mapped_column(Float, nullable=True)
    previous_close: Mapped[Optional[float]] = mapped_column(Float, nullable=True)
    market_cap: Mapped[Optional[float]] = mapped_column(Float, nullable=True)
    pe_ratio: Mapped[Optional[float]] = mapped_column(Float, nullable=True)

    # Additional metadata
    stock_metadata: Mapped[Optional[dict]] = mapped_column(JSONB, nullable=True)
    embedding: Mapped[Optional[List[float]]] = mapped_column(Vector(1536), nullable=True)

    # Timestamps
    created_at: Mapped[datetime] = mapped_column(DateTime, default=datetime.utcnow)
    updated_at: Mapped[datetime] = mapped_column(
        DateTime,
        default=datetime.utcnow,
        onupdate=datetime.utcnow
    )
    last_data_refresh: Mapped[Optional[datetime]] = mapped_column(DateTime, nullable=True)

    # Relationships
    watchlists: Mapped[List["Watchlist"]] = relationship("Watchlist", back_populates="stock")
    analyses: Mapped[List["StockAnalysis"]] = relationship("StockAnalysis", back_populates="stock")
    trading_signals: Mapped[List["TradingSignal"]] = relationship("TradingSignal", back_populates="stock")
    holdings: Mapped[List["PortfolioHolding"]] = relationship("PortfolioHolding", back_populates="stock")
    transactions: Mapped[List["PortfolioTransaction"]] = relationship("PortfolioTransaction", back_populates="stock")

    __table_args__ = (
        UniqueConstraint("symbol", "market", name="uq_stock_symbol_market"),
        Index("ix_stock_sector", "sector"),
        Index("ix_stock_embedding", "embedding", postgresql_using="ivfflat"),
    )

    def __repr__(self) -> str:
        return f"<Stock {self.symbol} ({self.market})>"


# -------------------------
# Portfolio Model (Container)
# -------------------------
class Portfolio(Base):
    """
    User's portfolio container.
    Each user can have multiple portfolios (Main, Growth, Dividend, etc.).
    """
    __tablename__ = "portfolios"

    id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True)
    user_id: Mapped[uuid.UUID] = mapped_column(
        UUID(as_uuid=True),
        ForeignKey("users.id", ondelete="CASCADE"),
        nullable=False,
        index=True
    )

    # Portfolio details
    name: Mapped[str] = mapped_column(String(100), nullable=False, default="My Portfolio")
    description: Mapped[Optional[str]] = mapped_column(Text, nullable=True)

    # Portfolio metrics (calculated periodically)
    total_invested: Mapped[float] = mapped_column(DECIMAL(15, 2), default=0.0)
    current_value: Mapped[float] = mapped_column(DECIMAL(15, 2), default=0.0)
    total_return: Mapped[float] = mapped_column(DECIMAL(15, 2), default=0.0)
    return_percentage: Mapped[float] = mapped_column(Float, default=0.0)

    # Timestamps
    created_at: Mapped[datetime] = mapped_column(DateTime, default=datetime.utcnow)
    updated_at: Mapped[datetime] = mapped_column(
        DateTime,
        default=datetime.utcnow,
        onupdate=datetime.utcnow
    )
    last_updated: Mapped[datetime] = mapped_column(DateTime, default=datetime.utcnow)

    # Relationships
    user: Mapped["User"] = relationship("User", back_populates="portfolios")
    holdings: Mapped[List["PortfolioHolding"]] = relationship(
        "PortfolioHolding",
        back_populates="portfolio",
        cascade="all, delete-orphan"
    )
    transactions: Mapped[List["PortfolioTransaction"]] = relationship(
        "PortfolioTransaction",
        back_populates="portfolio",
        cascade="all, delete-orphan"
    )

    def __repr__(self) -> str:
        return f"<Portfolio {self.name} (User: {self.user_id})>"


# -------------------------
# Portfolio Holding Model
# -------------------------
class PortfolioHolding(Base):
    """
    Individual stock holding in a portfolio.
    Tracks quantity, avg buy price, current value, and P&L.
    """
    __tablename__ = "portfolio_holdings"

    id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True)
    portfolio_id: Mapped[int] = mapped_column(
        Integer,
        ForeignKey("portfolios.id", ondelete="CASCADE"),
        nullable=False,
        index=True
    )
    stock_id: Mapped[int] = mapped_column(
        Integer,
        ForeignKey("stocks.id", ondelete="CASCADE"),
        nullable=False,
        index=True
    )

    # Holding details
    quantity: Mapped[int] = mapped_column(Integer, nullable=False)
    average_buy_price: Mapped[float] = mapped_column(DECIMAL(10, 2), nullable=False)
    total_invested: Mapped[float] = mapped_column(DECIMAL(15, 2), nullable=False)

    # Current values (updated periodically)
    current_price: Mapped[Optional[float]] = mapped_column(DECIMAL(10, 2), nullable=True)
    current_value: Mapped[Optional[float]] = mapped_column(DECIMAL(15, 2), nullable=True)
    unrealized_pl: Mapped[Optional[float]] = mapped_column(DECIMAL(15, 2), nullable=True)
    unrealized_pl_percentage: Mapped[Optional[float]] = mapped_column(Float, nullable=True)
    realized_pl: Mapped[float] = mapped_column(DECIMAL(15, 2), default=0.0)

    # Timestamps
    first_buy_date: Mapped[datetime] = mapped_column(DateTime, default=datetime.utcnow)
    last_updated: Mapped[datetime] = mapped_column(
        DateTime,
        default=datetime.utcnow,
        onupdate=datetime.utcnow
    )

    # Relationships
    portfolio: Mapped["Portfolio"] = relationship("Portfolio", back_populates="holdings")
    stock: Mapped["Stock"] = relationship("Stock", back_populates="holdings")
    transactions: Mapped[List["PortfolioTransaction"]] = relationship(
        "PortfolioTransaction",
        back_populates="holding"
    )

    __table_args__ = (
        UniqueConstraint("portfolio_id", "stock_id", name="uq_portfolio_stock_holding"),
    )

    def __repr__(self) -> str:
        return f"<Holding {self.stock_id} x{self.quantity} @ {self.average_buy_price}>"


# -------------------------
# Portfolio Transaction Model
# -------------------------
class PortfolioTransaction(Base):
    """
    Transaction history for portfolio (buy/sell records).
    """
    __tablename__ = "portfolio_transactions"

    id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True)
    portfolio_id: Mapped[int] = mapped_column(
        Integer,
        ForeignKey("portfolios.id", ondelete="CASCADE"),
        nullable=False,
        index=True
    )
    holding_id: Mapped[Optional[int]] = mapped_column(
        Integer,
        ForeignKey("portfolio_holdings.id", ondelete="SET NULL"),
        nullable=True
    )
    stock_id: Mapped[int] = mapped_column(
        Integer,
        ForeignKey("stocks.id", ondelete="CASCADE"),
        nullable=False
    )

    # Transaction details
    transaction_type: Mapped[TransactionType] = mapped_column(
        SQLEnum(TransactionType),
        nullable=False
    )
    quantity: Mapped[int] = mapped_column(Integer, nullable=False)
    price_per_share: Mapped[float] = mapped_column(DECIMAL(10, 2), nullable=False)
    total_amount: Mapped[float] = mapped_column(DECIMAL(15, 2), nullable=False)

    # Fees and charges
    brokerage_fee: Mapped[float] = mapped_column(DECIMAL(10, 2), default=0.0)
    tax: Mapped[float] = mapped_column(DECIMAL(10, 2), default=0.0)
    other_charges: Mapped[float] = mapped_column(DECIMAL(10, 2), default=0.0)

    # Transaction metadata
    transaction_date: Mapped[datetime] = mapped_column(DateTime, default=datetime.utcnow)
    notes: Mapped[Optional[str]] = mapped_column(Text, nullable=True)

    # Relationships
    portfolio: Mapped["Portfolio"] = relationship("Portfolio", back_populates="transactions")
    holding: Mapped[Optional["PortfolioHolding"]] = relationship(
        "PortfolioHolding",
        back_populates="transactions"
    )
    stock: Mapped["Stock"] = relationship("Stock", back_populates="transactions")

    __table_args__ = (
        Index("ix_transaction_date", "transaction_date"),
    )

    def __repr__(self) -> str:
        return f"<Transaction {self.transaction_type} {self.stock_id} x{self.quantity}>"


# -------------------------
# Watchlist Model
# -------------------------
class Watchlist(Base):
    """User's stock watchlist with price alerts."""
    __tablename__ = "watchlists"

    id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True)
    user_id: Mapped[uuid.UUID] = mapped_column(
        UUID(as_uuid=True),
        ForeignKey("users.id", ondelete="CASCADE"),
        nullable=False,
        index=True
    )
    stock_id: Mapped[int] = mapped_column(
        Integer,
        ForeignKey("stocks.id", ondelete="CASCADE"),
        nullable=False,
        index=True
    )

    # Alert settings
    alert_on_price_change: Mapped[bool] = mapped_column(Boolean, default=True)
    alert_threshold_percent: Mapped[float] = mapped_column(Float, default=5.0)
    alert_on_ai_signal: Mapped[bool] = mapped_column(Boolean, default=True)

    # Target prices
    target_buy_price: Mapped[Optional[float]] = mapped_column(Float, nullable=True)
    target_sell_price: Mapped[Optional[float]] = mapped_column(Float, nullable=True)
    notes: Mapped[Optional[str]] = mapped_column(Text, nullable=True)

    # Timestamps
    created_at: Mapped[datetime] = mapped_column(DateTime, default=datetime.utcnow)
    updated_at: Mapped[datetime] = mapped_column(
        DateTime,
        default=datetime.utcnow,
        onupdate=datetime.utcnow
    )

    # Relationships
    user: Mapped["User"] = relationship("User", back_populates="watchlists")
    stock: Mapped["Stock"] = relationship("Stock", back_populates="watchlists")

    __table_args__ = (
        UniqueConstraint("user_id", "stock_id", name="uq_user_stock_watchlist"),
    )

    def __repr__(self) -> str:
        return f"<Watchlist {self.user_id} - {self.stock_id}>"


# -------------------------
# StockAnalysis Model
# -------------------------
class StockAnalysis(Base):
    """AI-generated stock analysis results."""
    __tablename__ = "stock_analyses"

    id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True)
    stock_id: Mapped[int] = mapped_column(
        Integer,
        ForeignKey("stocks.id", ondelete="CASCADE"),
        nullable=False,
        index=True
    )

    # Analysis metadata
    analysis_type: Mapped[str] = mapped_column(String(50), nullable=False)
    confidence_score: Mapped[float] = mapped_column(Float, nullable=False)

    # Analysis results
    technical_indicators: Mapped[Optional[dict]] = mapped_column(JSONB, nullable=True)
    fundamental_metrics: Mapped[Optional[dict]] = mapped_column(JSONB, nullable=True)
    sentiment_analysis: Mapped[Optional[dict]] = mapped_column(JSONB, nullable=True)

    # AI insights
    summary: Mapped[str] = mapped_column(Text, nullable=False)
    recommendation: Mapped[SignalType] = mapped_column(SQLEnum(SignalType), nullable=False)
    reasoning: Mapped[str] = mapped_column(Text, nullable=False)
    risk_level: Mapped[str] = mapped_column(String(20), nullable=False)

    # Agent metadata
    agent_metadata: Mapped[Optional[dict]] = mapped_column(JSONB, nullable=True)
    llm_trace_id: Mapped[Optional[str]] = mapped_column(String(255), nullable=True)

    # Timestamps
    analyzed_at: Mapped[datetime] = mapped_column(DateTime, default=datetime.utcnow)
    valid_until: Mapped[Optional[datetime]] = mapped_column(DateTime, nullable=True)

    # Relationships
    stock: Mapped["Stock"] = relationship("Stock", back_populates="analyses")

    __table_args__ = (
        Index("ix_analysis_analyzed_at", "analyzed_at"),
        Index("ix_analysis_recommendation", "recommendation"),
    )

    def __repr__(self) -> str:
        return f"<Analysis {self.stock_id} - {self.recommendation}>"


# -------------------------
# TradingSignal Model
# -------------------------
class TradingSignal(Base):
    """Trading signals (buy/sell alerts)."""
    __tablename__ = "trading_signals"

    id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True)
    stock_id: Mapped[int] = mapped_column(
        Integer,
        ForeignKey("stocks.id", ondelete="CASCADE"),
        nullable=False,
        index=True
    )
    analysis_id: Mapped[Optional[int]] = mapped_column(
        Integer,
        ForeignKey("stock_analyses.id", ondelete="SET NULL"),
        nullable=True
    )

    # Signal details
    signal_type: Mapped[SignalType] = mapped_column(SQLEnum(SignalType), nullable=False)
    signal_strength: Mapped[float] = mapped_column(Float, nullable=False)

    # Price information
    trigger_price: Mapped[float] = mapped_column(Float, nullable=False)
    target_price: Mapped[Optional[float]] = mapped_column(Float, nullable=True)
    stop_loss: Mapped[Optional[float]] = mapped_column(Float, nullable=True)
    reason: Mapped[str] = mapped_column(Text, nullable=False)

    # Status
    is_active: Mapped[bool] = mapped_column(Boolean, default=True)
    executed: Mapped[bool] = mapped_column(Boolean, default=False)

    # Timestamps
    generated_at: Mapped[datetime] = mapped_column(DateTime, default=datetime.utcnow)
    expires_at: Mapped[Optional[datetime]] = mapped_column(DateTime, nullable=True)

    # Relationships
    stock: Mapped["Stock"] = relationship("Stock", back_populates="trading_signals")
    analysis: Mapped[Optional["StockAnalysis"]] = relationship("StockAnalysis")

    __table_args__ = (
        Index("ix_signal_generated_at", "generated_at"),
        Index("ix_signal_is_active", "is_active"),
    )

    def __repr__(self) -> str:
        return f"<Signal {self.signal_type} {self.stock_id}>"


# -------------------------
# Notification Model
# -------------------------
class Notification(Base):
    """Notification history."""
    __tablename__ = "notifications"

    id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True)
    user_id: Mapped[uuid.UUID] = mapped_column(
        UUID(as_uuid=True),
        ForeignKey("users.id", ondelete="CASCADE"),
        nullable=False,
        index=True
    )
    signal_id: Mapped[Optional[int]] = mapped_column(
        Integer,
        ForeignKey("trading_signals.id", ondelete="SET NULL"),
        nullable=True
    )

    # Notification details
    notification_type: Mapped[NotificationType] = mapped_column(
        SQLEnum(NotificationType),
        nullable=False
    )
    title: Mapped[str] = mapped_column(String(255), nullable=False)
    message: Mapped[str] = mapped_column(Text, nullable=False)

    # Delivery status
    status: Mapped[NotificationStatus] = mapped_column(
        SQLEnum(NotificationStatus),
        default=NotificationStatus.PENDING,
        nullable=False
    )
    error_message: Mapped[Optional[str]] = mapped_column(Text, nullable=True)

    # Read status
    is_read: Mapped[bool] = mapped_column(Boolean, default=False)
    read_at: Mapped[Optional[datetime]] = mapped_column(DateTime, nullable=True)

    # Timestamps
    created_at: Mapped[datetime] = mapped_column(DateTime, default=datetime.utcnow)
    sent_at: Mapped[Optional[datetime]] = mapped_column(DateTime, nullable=True)

    # Relationships
    user: Mapped["User"] = relationship("User", back_populates="notifications")
    signal: Mapped[Optional["TradingSignal"]] = relationship("TradingSignal")

    __table_args__ = (
        Index("ix_notification_created_at", "created_at"),
        Index("ix_notification_status", "status"),
    )

    def __repr__(self) -> str:
        return f"<Notification {self.title} ({self.status})>"


# -------------------------
# Order Types
# -------------------------
class OrderType(str, enum.Enum):
    """Order types."""
    MARKET = "market"
    LIMIT = "limit"
    STOP_LOSS = "stop_loss"
    STOP_LIMIT = "stop_limit"


class OrderStatus(str, enum.Enum):
    """Order status."""
    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIALLY_FILLED = "partially_filled"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"
    EXPIRED = "expired"


# -------------------------
# Order Model
# -------------------------
class Order(Base):
    """Trading orders."""
    __tablename__ = "orders"

    id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True)
    user_id: Mapped[uuid.UUID] = mapped_column(
        UUID(as_uuid=True),
        ForeignKey("users.id", ondelete="CASCADE"),
        nullable=False,
        index=True
    )
    stock_id: Mapped[int] = mapped_column(
        Integer,
        ForeignKey("stocks.id", ondelete="CASCADE"),
        nullable=False,
        index=True
    )

    # Order details
    order_type: Mapped[OrderType] = mapped_column(SQLEnum(OrderType), nullable=False)
    side: Mapped[TransactionType] = mapped_column(SQLEnum(TransactionType), nullable=False)  # BUY or SELL
    quantity: Mapped[int] = mapped_column(Integer, nullable=False)
    
    # Price details
    limit_price: Mapped[Optional[float]] = mapped_column(DECIMAL(10, 2), nullable=True)
    stop_price: Mapped[Optional[float]] = mapped_column(DECIMAL(10, 2), nullable=True)
    
    # Execution details
    status: Mapped[OrderStatus] = mapped_column(
        SQLEnum(OrderStatus),
        default=OrderStatus.PENDING,
        nullable=False
    )
    filled_quantity: Mapped[int] = mapped_column(Integer, default=0)
    average_fill_price: Mapped[Optional[float]] = mapped_column(DECIMAL(10, 2), nullable=True)
    total_filled_value: Mapped[float] = mapped_column(DECIMAL(15, 2), default=0.0)
    
    # Fees
    commission: Mapped[float] = mapped_column(DECIMAL(10, 2), default=0.0)
    fees: Mapped[float] = mapped_column(DECIMAL(10, 2), default=0.0)
    
    # Timestamps
    created_at: Mapped[datetime] = mapped_column(DateTime, default=datetime.utcnow)
    submitted_at: Mapped[Optional[datetime]] = mapped_column(DateTime, nullable=True)
    filled_at: Mapped[Optional[datetime]] = mapped_column(DateTime, nullable=True)
    cancelled_at: Mapped[Optional[datetime]] = mapped_column(DateTime, nullable=True)
    expires_at: Mapped[Optional[datetime]] = mapped_column(DateTime, nullable=True)
    
    # Metadata
    notes: Mapped[Optional[str]] = mapped_column(Text, nullable=True)
    order_metadata: Mapped[Optional[dict]] = mapped_column(JSONB, nullable=True)

    # Relationships
    user: Mapped["User"] = relationship("User")
    stock: Mapped["Stock"] = relationship("Stock")

    __table_args__ = (
        Index("ix_order_status", "status"),
        Index("ix_order_created_at", "created_at"),
        Index("ix_order_user_status", "user_id", "status"),
    )

    def __repr__(self) -> str:
        return f"<Order {self.order_type} {self.side} {self.quantity} @ {self.limit_price or 'MARKET'}>"


# -------------------------
# KYC Verification Model
# -------------------------
class KYCVerification(Base):
    """KYC/AML verification records."""
    __tablename__ = "kyc_verifications"

    id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True)
    user_id: Mapped[uuid.UUID] = mapped_column(
        UUID(as_uuid=True),
        ForeignKey("users.id", ondelete="CASCADE"),
        nullable=False,
        unique=True,
        index=True
    )

    # Verification status
    status: Mapped[str] = mapped_column(String(20), default="pending", nullable=False)
    verification_level: Mapped[str] = mapped_column(String(20), default="basic", nullable=False)
    
    # Document storage (in production, store in S3 and keep references)
    documents: Mapped[Optional[dict]] = mapped_column(JSONB, nullable=True)
    
    # Verification metadata
    verified_at: Mapped[Optional[datetime]] = mapped_column(DateTime, nullable=True)
    verified_by: Mapped[Optional[str]] = mapped_column(String(255), nullable=True)
    rejection_reason: Mapped[Optional[str]] = mapped_column(Text, nullable=True)
    
    # AML check results
    aml_risk_score: Mapped[Optional[float]] = mapped_column(Float, nullable=True)
    aml_risk_level: Mapped[Optional[str]] = mapped_column(String(20), nullable=True)
    aml_checked_at: Mapped[Optional[datetime]] = mapped_column(DateTime, nullable=True)
    
    # Timestamps
    created_at: Mapped[datetime] = mapped_column(DateTime, default=datetime.utcnow)
    updated_at: Mapped[datetime] = mapped_column(
        DateTime,
        default=datetime.utcnow,
        onupdate=datetime.utcnow
    )

    # Relationships
    user: Mapped["User"] = relationship("User")

    def __repr__(self) -> str:
        return f"<KYCVerification {self.user_id} - {self.status}>"
