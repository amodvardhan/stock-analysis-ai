"""
=============================================================================
AI Hub - Database Models (Tables)
=============================================================================
Defines all database tables using SQLAlchemy ORM.

Tables:
1. User - User accounts and authentication
2. Portfolio - User's stock portfolios
3. Stock - Stock information and cached data
4. Watchlist - Stocks user wants to monitor
5. StockAnalysis - AI-generated analysis results
6. Notification - Notification history
7. TradingSignal - Buy/sell signals generated by AI
=============================================================================
"""

from datetime import datetime
from typing import List, Optional
from sqlalchemy import (
    Boolean,
    Column,
    DateTime,
    Float,
    ForeignKey,
    Integer,
    String,
    Text,
    UniqueConstraint,
    Index,
    Enum as SQLEnum,
)
from sqlalchemy.orm import Mapped, mapped_column, relationship
from sqlalchemy.dialects.postgresql import JSONB, UUID
from pgvector.sqlalchemy import Vector
import enum
import uuid

from core.database import Base


# -------------------------
# Enumerations
# -------------------------
class MarketType(str, enum.Enum):
    """Stock market types"""
    INDIA_NSE = "india_nse"
    INDIA_BSE = "india_bse"
    US_NYSE = "us_nyse"
    US_NASDAQ = "us_nasdaq"


class SignalType(str, enum.Enum):
    """Trading signal types"""
    BUY = "buy"
    SELL = "sell"
    HOLD = "hold"


class NotificationType(str, enum.Enum):
    """Notification delivery methods"""
    EMAIL = "email"
    SMS = "sms"
    IN_APP = "in_app"


class NotificationStatus(str, enum.Enum):
    """Notification delivery status"""
    PENDING = "pending"
    SENT = "sent"
    FAILED = "failed"


# -------------------------
# User Model
# -------------------------
class User(Base):
    """
    User account table.
    
    Stores user credentials, preferences, and notification settings.
    Each user can have multiple portfolios and watchlists.
    """
    __tablename__ = "users"
    
    # Primary key
    id: Mapped[uuid.UUID] = mapped_column(
        UUID(as_uuid=True),
        primary_key=True,
        default=uuid.uuid4,
        comment="Unique user identifier"
    )
    
    # Authentication fields
    email: Mapped[str] = mapped_column(
        String(255),
        unique=True,
        nullable=False,
        index=True,
        comment="User email (used for login)"
    )
    hashed_password: Mapped[str] = mapped_column(
        String(255),
        nullable=False,
        comment="Bcrypt hashed password"
    )
    
    # Profile information
    full_name: Mapped[str] = mapped_column(
        String(255),
        nullable=False,
        comment="User's full name"
    )
    phone_number: Mapped[Optional[str]] = mapped_column(
        String(20),
        nullable=True,
        comment="Phone number for SMS notifications"
    )
    
    # User preferences
    risk_tolerance: Mapped[Optional[str]] = mapped_column(
        String(20),
        default="moderate",
        comment="Risk tolerance: conservative, moderate, aggressive"
    )
    preferred_markets: Mapped[Optional[dict]] = mapped_column(
        JSONB,
        default=list,
        comment="List of preferred markets (NSE, NYSE, etc.)"
    )
    
    # Notification preferences
    email_notifications: Mapped[bool] = mapped_column(
        Boolean,
        default=True,
        comment="Enable email notifications"
    )
    sms_notifications: Mapped[bool] = mapped_column(
        Boolean,
        default=False,
        comment="Enable SMS notifications"
    )
    
    # Account status
    is_active: Mapped[bool] = mapped_column(
        Boolean,
        default=True,
        comment="Account active status"
    )
    is_verified: Mapped[bool] = mapped_column(
        Boolean,
        default=False,
        comment="Email verification status"
    )
    
    # Timestamps
    created_at: Mapped[datetime] = mapped_column(
        DateTime,
        default=datetime.utcnow,
        comment="Account creation timestamp"
    )
    updated_at: Mapped[datetime] = mapped_column(
        DateTime,
        default=datetime.utcnow,
        onupdate=datetime.utcnow,
        comment="Last update timestamp"
    )
    last_login: Mapped[Optional[datetime]] = mapped_column(
        DateTime,
        nullable=True,
        comment="Last login timestamp"
    )
    
    # Relationships (one-to-many)
    portfolios: Mapped[List["Portfolio"]] = relationship(
        "Portfolio",
        back_populates="user",
        cascade="all, delete-orphan"
    )
    watchlists: Mapped[List["Watchlist"]] = relationship(
        "Watchlist",
        back_populates="user",
        cascade="all, delete-orphan"
    )
    notifications: Mapped[List["Notification"]] = relationship(
        "Notification",
        back_populates="user",
        cascade="all, delete-orphan"
    )
    
    def __repr__(self) -> str:
        return f"<User(email='{self.email}', name='{self.full_name}')>"


# -------------------------
# Stock Model
# -------------------------
class Stock(Base):
    """
    Stock information table.
    
    Stores basic stock information and caches market data.
    Includes vector embeddings for similarity search.
    """
    __tablename__ = "stocks"
    
    id: Mapped[int] = mapped_column(
        Integer,
        primary_key=True,
        autoincrement=True
    )
    
    # Stock identifiers
    symbol: Mapped[str] = mapped_column(
        String(20),
        nullable=False,
        index=True,
        comment="Stock ticker symbol (e.g., RELIANCE, AAPL)"
    )
    market: Mapped[MarketType] = mapped_column(
        SQLEnum(MarketType),
        nullable=False,
        comment="Stock market (NSE, NYSE, etc.)"
    )
    
    # Stock information
    company_name: Mapped[str] = mapped_column(
        String(255),
        nullable=False,
        comment="Full company name"
    )
    sector: Mapped[Optional[str]] = mapped_column(
        String(100),
        nullable=True,
        comment="Business sector (Technology, Finance, etc.)"
    )
    industry: Mapped[Optional[str]] = mapped_column(
        String(100),
        nullable=True,
        comment="Industry classification"
    )
    
    # Cached market data (updated periodically)
    current_price: Mapped[Optional[float]] = mapped_column(
        Float,
        nullable=True,
        comment="Latest stock price"
    )
    previous_close: Mapped[Optional[float]] = mapped_column(
        Float,
        nullable=True,
        comment="Previous day closing price"
    )
    market_cap: Mapped[Optional[float]] = mapped_column(
        Float,
        nullable=True,
        comment="Market capitalization"
    )
    pe_ratio: Mapped[Optional[float]] = mapped_column(
        Float,
        nullable=True,
        comment="Price-to-Earnings ratio"
    )
    
    # Additional data as JSON - RENAMED from 'metadata' to 'stock_metadata'
    stock_metadata: Mapped[Optional[dict]] = mapped_column(
        JSONB,
        nullable=True,
        comment="Additional stock metadata (52-week high/low, dividend, etc.)"
    )
    
    # Vector embedding for similarity search (1536 dimensions for OpenAI embeddings)
    embedding: Mapped[Optional[List[float]]] = mapped_column(
        Vector(1536),
        nullable=True,
        comment="Vector embedding for stock characteristics (for pattern matching)"
    )
    
    # Timestamps
    created_at: Mapped[datetime] = mapped_column(DateTime, default=datetime.utcnow)
    updated_at: Mapped[datetime] = mapped_column(
        DateTime,
        default=datetime.utcnow,
        onupdate=datetime.utcnow
    )
    last_data_refresh: Mapped[Optional[datetime]] = mapped_column(
        DateTime,
        nullable=True,
        comment="When market data was last fetched"
    )
    
    # Relationships
    watchlists: Mapped[List["Watchlist"]] = relationship(
        "Watchlist",
        back_populates="stock"
    )
    analyses: Mapped[List["StockAnalysis"]] = relationship(
        "StockAnalysis",
        back_populates="stock"
    )
    trading_signals: Mapped[List["TradingSignal"]] = relationship(
        "TradingSignal",
        back_populates="stock"
    )
    
    # Constraints
    __table_args__ = (
        UniqueConstraint("symbol", "market", name="uq_stock_symbol_market"),
        Index("ix_stock_sector", "sector"),
        Index("ix_stock_embedding", "embedding", postgresql_using="ivfflat"),
    )
    
    def __repr__(self) -> str:
        return f"<Stock(symbol='{self.symbol}', market='{self.market.value}')>"


# -------------------------
# Portfolio Model
# -------------------------
class Portfolio(Base):
    """
    User's stock portfolio table.
    
    Tracks stocks owned by the user, purchase details, and current value.
    """
    __tablename__ = "portfolios"
    
    id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True)
    
    # Foreign keys
    user_id: Mapped[uuid.UUID] = mapped_column(
        UUID(as_uuid=True),
        ForeignKey("users.id", ondelete="CASCADE"),
        nullable=False,
        index=True
    )
    stock_id: Mapped[int] = mapped_column(
        Integer,
        ForeignKey("stocks.id", ondelete="CASCADE"),
        nullable=False,
        index=True
    )
    
    # Purchase details
    quantity: Mapped[float] = mapped_column(
        Float,
        nullable=False,
        comment="Number of shares owned"
    )
    purchase_price: Mapped[float] = mapped_column(
        Float,
        nullable=False,
        comment="Price per share at purchase"
    )
    purchase_date: Mapped[datetime] = mapped_column(
        DateTime,
        nullable=False,
        comment="Date of purchase"
    )
    
    # Current status
    current_value: Mapped[Optional[float]] = mapped_column(
        Float,
        nullable=True,
        comment="Current value (updated periodically)"
    )
    profit_loss: Mapped[Optional[float]] = mapped_column(
        Float,
        nullable=True,
        comment="Profit/loss amount"
    )
    profit_loss_percent: Mapped[Optional[float]] = mapped_column(
        Float,
        nullable=True,
        comment="Profit/loss percentage"
    )
    
    # Timestamps
    created_at: Mapped[datetime] = mapped_column(DateTime, default=datetime.utcnow)
    updated_at: Mapped[datetime] = mapped_column(
        DateTime,
        default=datetime.utcnow,
        onupdate=datetime.utcnow
    )
    
    # Relationships
    user: Mapped["User"] = relationship("User", back_populates="portfolios")
    stock: Mapped["Stock"] = relationship("Stock")
    
    def __repr__(self) -> str:
        return f"<Portfolio(user_id={self.user_id}, stock_id={self.stock_id}, qty={self.quantity})>"


# -------------------------
# Watchlist Model
# -------------------------
class Watchlist(Base):
    """
    User's stock watchlist table.
    
    Stocks that users want to monitor for buy/sell opportunities.
    AI agents continuously analyze these stocks.
    """
    __tablename__ = "watchlists"
    
    id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True)
    
    # Foreign keys
    user_id: Mapped[uuid.UUID] = mapped_column(
        UUID(as_uuid=True),
        ForeignKey("users.id", ondelete="CASCADE"),
        nullable=False,
        index=True
    )
    stock_id: Mapped[int] = mapped_column(
        Integer,
        ForeignKey("stocks.id", ondelete="CASCADE"),
        nullable=False,
        index=True
    )
    
    # Monitoring settings
    alert_on_price_change: Mapped[bool] = mapped_column(
        Boolean,
        default=True,
        comment="Alert when price changes significantly"
    )
    alert_threshold_percent: Mapped[float] = mapped_column(
        Float,
        default=5.0,
        comment="Price change % that triggers alert"
    )
    alert_on_ai_signal: Mapped[bool] = mapped_column(
        Boolean,
        default=True,
        comment="Alert when AI generates buy/sell signal"
    )
    
    # Target prices (optional)
    target_buy_price: Mapped[Optional[float]] = mapped_column(
        Float,
        nullable=True,
        comment="Alert when price drops to this level"
    )
    target_sell_price: Mapped[Optional[float]] = mapped_column(
        Float,
        nullable=True,
        comment="Alert when price rises to this level"
    )
    
    # User notes
    notes: Mapped[Optional[str]] = mapped_column(
        Text,
        nullable=True,
        comment="User's notes about this stock"
    )
    
    # Timestamps
    created_at: Mapped[datetime] = mapped_column(DateTime, default=datetime.utcnow)
    updated_at: Mapped[datetime] = mapped_column(
        DateTime,
        default=datetime.utcnow,
        onupdate=datetime.utcnow
    )
    
    # Relationships
    user: Mapped["User"] = relationship("User", back_populates="watchlists")
    stock: Mapped["Stock"] = relationship("Stock", back_populates="watchlists")
    
    # Constraints
    __table_args__ = (
        UniqueConstraint("user_id", "stock_id", name="uq_user_stock_watchlist"),
    )
    
    def __repr__(self) -> str:
        return f"<Watchlist(user_id={self.user_id}, stock_id={self.stock_id})>"


# -------------------------
# StockAnalysis Model
# -------------------------
class StockAnalysis(Base):
    """
    AI-generated stock analysis results table.
    
    Stores the output from AI agents analyzing stocks.
    Includes technical analysis, fundamental analysis, sentiment, etc.
    """
    __tablename__ = "stock_analyses"
    
    id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True)
    
    # Foreign key
    stock_id: Mapped[int] = mapped_column(
        Integer,
        ForeignKey("stocks.id", ondelete="CASCADE"),
        nullable=False,
        index=True
    )
    
    # Analysis metadata
    analysis_type: Mapped[str] = mapped_column(
        String(50),
        nullable=False,
        comment="Type: technical, fundamental, sentiment, comprehensive"
    )
    confidence_score: Mapped[float] = mapped_column(
        Float,
        nullable=False,
        comment="AI confidence in this analysis (0.0-1.0)"
    )
    
    # Analysis results (structured JSON)
    technical_indicators: Mapped[Optional[dict]] = mapped_column(
        JSONB,
        nullable=True,
        comment="RSI, MACD, Bollinger Bands, etc."
    )
    fundamental_metrics: Mapped[Optional[dict]] = mapped_column(
        JSONB,
        nullable=True,
        comment="P/E, debt ratio, revenue growth, etc."
    )
    sentiment_analysis: Mapped[Optional[dict]] = mapped_column(
        JSONB,
        nullable=True,
        comment="News sentiment, social media sentiment, etc."
    )
    
    # AI-generated insights
    summary: Mapped[str] = mapped_column(
        Text,
        nullable=False,
        comment="Human-readable summary of the analysis"
    )
    recommendation: Mapped[SignalType] = mapped_column(
        SQLEnum(SignalType),
        nullable=False,
        comment="Overall recommendation: buy, sell, hold"
    )
    reasoning: Mapped[str] = mapped_column(
        Text,
        nullable=False,
        comment="Detailed reasoning for the recommendation"
    )
    
    # Risk assessment
    risk_level: Mapped[str] = mapped_column(
        String(20),
        nullable=False,
        comment="Risk level: low, moderate, high"
    )
    risk_factors: Mapped[Optional[list]] = mapped_column(
        JSONB,
        nullable=True,
        comment="List of identified risks"
    )
    
    # Agent attribution
    agent_metadata: Mapped[Optional[dict]] = mapped_column(
        JSONB,
        nullable=True,
        comment="Which agents contributed to this analysis"
    )
    llm_trace_id: Mapped[Optional[str]] = mapped_column(
        String(255),
        nullable=True,
        comment="LangSmith trace ID for debugging"
    )
    
    # Timestamps
    analyzed_at: Mapped[datetime] = mapped_column(
        DateTime,
        default=datetime.utcnow,
        comment="When this analysis was performed"
    )
    valid_until: Mapped[Optional[datetime]] = mapped_column(
        DateTime,
        nullable=True,
        comment="When this analysis becomes stale"
    )
    
    # Relationships
    stock: Mapped["Stock"] = relationship("Stock", back_populates="analyses")
    
    # Indexes
    __table_args__ = (
        Index("ix_analysis_analyzed_at", "analyzed_at"),
        Index("ix_analysis_recommendation", "recommendation"),
    )
    
    def __repr__(self) -> str:
        return f"<StockAnalysis(stock_id={self.stock_id}, recommendation='{self.recommendation.value}')>"


# -------------------------
# TradingSignal Model
# -------------------------
class TradingSignal(Base):
    """
    Trading signals (buy/sell alerts) table.
    
    Generated by AI when it identifies trading opportunities.
    Triggers notifications to users.
    """
    __tablename__ = "trading_signals"
    
    id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True)
    
    # Foreign key
    stock_id: Mapped[int] = mapped_column(
        Integer,
        ForeignKey("stocks.id", ondelete="CASCADE"),
        nullable=False,
        index=True
    )
    analysis_id: Mapped[Optional[int]] = mapped_column(
        Integer,
        ForeignKey("stock_analyses.id", ondelete="SET NULL"),
        nullable=True,
        comment="Related analysis that generated this signal"
    )
    
    # Signal details
    signal_type: Mapped[SignalType] = mapped_column(
        SQLEnum(SignalType),
        nullable=False,
        comment="Signal type: buy, sell, hold"
    )
    signal_strength: Mapped[float] = mapped_column(
        Float,
        nullable=False,
        comment="Signal strength (0.0-1.0)"
    )
    
    # Price information
    trigger_price: Mapped[float] = mapped_column(
        Float,
        nullable=False,
        comment="Stock price when signal was generated"
    )
    target_price: Mapped[Optional[float]] = mapped_column(
        Float,
        nullable=True,
        comment="Suggested target price"
    )
    stop_loss: Mapped[Optional[float]] = mapped_column(
        Float,
        nullable=True,
        comment="Suggested stop-loss price"
    )
    
    # Signal reasoning
    reason: Mapped[str] = mapped_column(
        Text,
        nullable=False,
        comment="Why this signal was generated"
    )
    
    # Status tracking
    is_active: Mapped[bool] = mapped_column(
        Boolean,
        default=True,
        comment="Whether this signal is still valid"
    )
    executed: Mapped[bool] = mapped_column(
        Boolean,
        default=False,
        comment="Whether user acted on this signal"
    )
    
    # Timestamps
    generated_at: Mapped[datetime] = mapped_column(
        DateTime,
        default=datetime.utcnow,
        comment="When signal was generated"
    )
    expires_at: Mapped[Optional[datetime]] = mapped_column(
        DateTime,
        nullable=True,
        comment="When signal expires"
    )
    
    # Relationships
    stock: Mapped["Stock"] = relationship("Stock", back_populates="trading_signals")
    analysis: Mapped[Optional["StockAnalysis"]] = relationship("StockAnalysis")
    
    # Indexes
    __table_args__ = (
        Index("ix_signal_generated_at", "generated_at"),
        Index("ix_signal_is_active", "is_active"),
    )
    
    def __repr__(self) -> str:
        return f"<TradingSignal(stock_id={self.stock_id}, type='{self.signal_type.value}', strength={self.signal_strength})>"


# -------------------------
# Notification Model
# -------------------------
class Notification(Base):
    """
    Notification history table.
    
    Tracks all notifications sent to users (email, SMS, in-app).
    """
    __tablename__ = "notifications"
    
    id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True)
    
    # Foreign keys
    user_id: Mapped[uuid.UUID] = mapped_column(
        UUID(as_uuid=True),
        ForeignKey("users.id", ondelete="CASCADE"),
        nullable=False,
        index=True
    )
    signal_id: Mapped[Optional[int]] = mapped_column(
        Integer,
        ForeignKey("trading_signals.id", ondelete="SET NULL"),
        nullable=True,
        comment="Related trading signal (if applicable)"
    )
    
    # Notification details
    notification_type: Mapped[NotificationType] = mapped_column(
        SQLEnum(NotificationType),
        nullable=False,
        comment="Delivery method: email, sms, in_app"
    )
    title: Mapped[str] = mapped_column(
        String(255),
        nullable=False,
        comment="Notification title/subject"
    )
    message: Mapped[str] = mapped_column(
        Text,
        nullable=False,
        comment="Notification message body"
    )
    
    # Delivery status
    status: Mapped[NotificationStatus] = mapped_column(
        SQLEnum(NotificationStatus),
        default=NotificationStatus.PENDING,
        nullable=False,
        comment="Delivery status: pending, sent, failed"
    )
    error_message: Mapped[Optional[str]] = mapped_column(
        Text,
        nullable=True,
        comment="Error message if delivery failed"
    )
    
    # Read status (for in-app notifications)
    is_read: Mapped[bool] = mapped_column(
        Boolean,
        default=False,
        comment="Whether user has read this notification"
    )
    read_at: Mapped[Optional[datetime]] = mapped_column(
        DateTime,
        nullable=True,
        comment="When user read the notification"
    )
    
    # Timestamps
    created_at: Mapped[datetime] = mapped_column(
        DateTime,
        default=datetime.utcnow,
        comment="When notification was created"
    )
    sent_at: Mapped[Optional[datetime]] = mapped_column(
        DateTime,
        nullable=True,
        comment="When notification was sent"
    )
    
    # Relationships
    user: Mapped["User"] = relationship("User", back_populates="notifications")
    signal: Mapped[Optional["TradingSignal"]] = relationship("TradingSignal")
    
    # Indexes
    __table_args__ = (
        Index("ix_notification_created_at", "created_at"),
        Index("ix_notification_status", "status"),
    )
    
    def __repr__(self) -> str:
        return f"<Notification(user_id={self.user_id}, type='{self.notification_type.value}', status='{self.status.value}')>"
